{"version":3,"sources":["services/storage/storage.web.ts","services/storage/storage.stub.ts","providers/storage.provider.ts","features/options/options.context.tsx","features/options/options.provider.tsx","features/flashcard/flashcard.tsx","features/options/useOptions.hook.ts","features/options/Options.tsx","pages/useDeck.hook.ts","services/deck-loader/deck-loader.web.ts","pages/flashcard.page.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Storage","getValue","key","json","localStorage","getItem","Promise","resolve","then","JSON","parse","setValue","value","stringify","setItem","remove","hasKey","console","error","log","StorageProvider","React","createContext","OptionsContext","options","selectedDeck","theme","setOptions","OptionsProvider","children","browserTheme","window","matchMedia","matches","useState","storage","useContext","useEffect","storedOptions","newOptions","Object","entries","reduce","defaultValue","Provider","Flashcard","deck","index","setIndex","isFront","setIsFront","showRandomCard","Math","floor","random","length","card","front","back","text","onClick","className","style","useOptions","deckManifest","fileName","title","Options","onUpdate","updateOptions","onChange","e","filename","target","paddingLeft","map","name","type","checked","useDeck","initialized","setInitialized","setDeck","loadDeck","root","fetch","res","setExistingDeck","FlashCardPage","paddingTop","AppRoot","isLightTheme","newTheme","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e6ef076d.chunk.js","sourcesContent":["export const getValue = (key: string) => {\n  const json = localStorage.getItem(key) ?? \"null\";\n\n  return Promise.resolve()\n    .then(() => JSON.parse(json));\n};\n\nexport const setValue = (key: string, value: any) => {\n  const json = value == null\n    ? JSON.stringify(null)\n    : JSON.stringify(value);\n\n  return Promise.resolve()\n    .then(() => localStorage.setItem(key, json));\n};\n\nexport const remove = () => {};\nexport const hasKey = () => {};\n\nconst Storage = {\n  getValue,\n  setValue,\n  remove,\n  hasKey,\n};\n\nexport default Storage;\n","export const getValue = (key: string) => {\n  console.error(\"Storage not implemented\");\n  console.log(`tried to load ${key}`);\n  return Promise.resolve() as Promise<any>;\n};\n\nexport const setValue = (key: string, value: any) => {\n  console.error(\"Storage not implemented\");\n  console.log(`tried to set ${key}`);\n  return Promise.resolve() as Promise<void>;\n};\n\nexport const remove = () => {};\nexport const hasKey = () => {};\n\nconst Storage = {\n  getValue,\n  setValue,\n  remove,\n  hasKey,\n};\n\nexport default Storage;\n","import React from \"react\";\nimport Storage from \"../services/storage/storage.stub\";\n\nconst StorageProvider = React.createContext<typeof Storage>(Storage);\nexport default StorageProvider;\n","import { createContext } from \"react\";\nimport { OptionsState } from \"./options.types\";\n\nconst OptionsContext = createContext<OptionsState>({\n  options: { selectedDeck: \"\" , theme: \"light\" },\n  setOptions: () => {}\n});\n\nexport default OptionsContext;\n\n// const useOptions = () => {\n//   const { state, setState } = useContext(OptionsContext);\n//   return [state, setState];\n// };\n\n// const Component = () => {\n//   const [options, setOptions] = useOptions();\n//   return null;\n// };\n\n\n// render(<OptionsContext.Provider value={{ state: {}, setState: () => {} }}><Component /></OptionsContext.Provider>)","import React, {useState, useEffect, useContext} from \"react\";\nimport Storage from \"../../providers/storage.provider\";\nimport {Options} from \"./options.types\";\nimport OptionsContext from \"./options.context\";\n\nconst OptionsProvider = ({ children }: { children: React.ReactChildren | React.ReactChild | null }) => {\n  const browserTheme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches\n    ? \"dark\" : \"light\";\n  \n  const [options, setOptions] = useState<Options>({ selectedDeck: \"ES-EN\", theme: browserTheme });\n  const storage = useContext(Storage);\n\n  useEffect(() => {\n    storage.getValue(\"preferences\")\n      .then((storedOptions: Options) => {\n        if (!storedOptions)\n          return;\n\n        const newOptions = Object.entries(options)\n          .reduce((options, [key, defaultValue]) => {\n            const value = storedOptions[key] ?? defaultValue;\n            return { ...options, [key]: value };\n          }, {} as Partial<Options>);\n\n        setOptions(newOptions as Options);\n      });\n  }, []);\n\n  return (\n    <OptionsContext.Provider value={{ options, setOptions }}>\n      {children}\n    </OptionsContext.Provider>\n  );\n};\n\nexport default OptionsProvider;\n","import React, { useState, useEffect } from 'react'\nimport type { Card } from '../../types/types'\n/*\n\n*/\ntype FlashcardProps = { deck: Card[] };\n\nexport const Flashcard = ({ deck }: FlashcardProps): JSX.Element => {\n    const [index, setIndex] = useState<number>(0);\n    const [isFront, setIsFront] = useState<boolean>(true);\n    const showRandomCard = () => {\n        setIndex(Math.floor(Math.random() * deck.length));\n        setIsFront(true);\n    };\n\n    useEffect(() => {\n        showRandomCard();\n    }, [deck]);\n\n    const flipcard = () => {\n        setIsFront(!isFront);\n    };\n\n    const card = deck[index] ?? { front: \"\", back: \"\" };\n    const text = isFront ? card.front : card.back;\n    return (\n        <div>\n            <div onClick={flipcard} className=\"card\">\n                <h1>{text}</h1>\n                <div style={{ \"position\": \"absolute\", \"bottom\": \"0\" }}>\n                    <span>click card to show reverse</span>\n                </div>\n            </div>\n            <button className=\"show_random_card_btn\" onClick={showRandomCard}>Random Card</button>\n        </div>\n    )\n}","import { useContext } from \"react\";\nimport Storage from \"../../providers/storage.provider\";\nimport OptionsContext from \"./options.context\";\nimport { Options } from \"./options.types\";\n\nexport const useOptions = () => {\n  const { options, setOptions } = useContext(OptionsContext);\n  const storage = useContext(Storage);\n\n  const updateOptions = (options: Options) => {\n    storage.setValue(\"preferences\", options)\n      .then(() => setOptions(options));\n  };\n\n  return [options, updateOptions] as const;\n};\n\n/*\n  TODO:\n    integrate into Options component\n    integrate into FlashCard page\n    integrate into Deck hook\n\n    - make an OptionsProvider component which wraps OptionsContext and\n      - handles state / setState so that App doesn't need to\n      - handles the initialization useEffect so that nothing further down the app needs to \n*/","import { useContext } from 'react'\nimport StorageProvider from '../../providers/storage.provider'\nimport {\n    // usePreferences,\n    Preferences\n} from './usePreferences.hook'\nimport {useOptions} from './useOptions.hook'\n\nconst deckManifest = [\n    {\n        fileName: \"ES-EN\",\n        title: \"Spanish to English\"\n    },\n    {\n        fileName: \"FR-EN\",\n        title: \"French to English\"\n    },\n    {\n        fileName: \"EN-ES\",\n        title: \"English to Spanish\"\n    },\n    {\n        fileName: \"EN-FR\",\n        title: \"English to French\"\n    },\n];\n\ntype OptionsProps = {\n  onUpdate?: (preferences: Preferences) => void;\n};\n\nexport const Options = ({ onUpdate }: OptionsProps) => {\n    const storage = useContext(StorageProvider);\n    const [options, updateOptions] = useOptions();\n    const updateSelectedDeck = (e: any) => {\n      const filename = (e.target as HTMLInputElement).value;\n      const newOptions = {\n        ...options,\n        selectedDeck: filename\n      };\n\n      updateOptions(newOptions);\n    };\n\n    return (\n        <section>\n            <fieldset className=\"option-list\" onChange={updateSelectedDeck}>\n                <legend className=\"option-header\">Choose your deck</legend>\n                <ul style={{\"display\": \"inline-block\", \"listStyle\": \"none\", paddingLeft: \"0\" }}>\n                    {deckManifest.map((deck) => \n                        <li className=\"option-card\" style={{ \"textAlign\": \"left\"}}>\n                            <label>\n                                <input\n                                    value={deck.fileName}\n                                    name=\"deck\"\n                                    type=\"radio\"\n                                    checked={options.selectedDeck === deck.fileName}\n                                    />&nbsp;\n                                        <span>{deck.title}</span>\n                            </label>\n                        </li>\n                    )}\n                </ul>\n            </fieldset>\n        </section>\n\n    )\n\n}\n\n","import {useContext, useEffect, useState, useCallback} from 'react'\nimport Storage from '../providers/storage.provider'\nimport {useOptions} from '../features/options/useOptions.hook'\nimport {getDeck} from '../services/deck-loader/deck-loader.web'\nimport {Deck} from '../types/types'\n\nexport const useDeck = () => {\n  const [options] = useOptions();\n  const [initialized, setInitialized] = useState(false);\n  const [deck, setDeck] = useState<Deck>([]);\n  const storage = useContext(Storage);\n\n  const loadDeck = (filename: string) =>\n    getDeck(\"/data\", filename)\n      .then(deck =>\n        storage.setValue(\"deck\", deck)\n          .then(() => setDeck(deck)));\n\n  useEffect(() => {\n    const setExistingDeck = (deck: Deck) =>\n      Promise.resolve(deck).then(setDeck);\n\n    storage.getValue(\"deck\")\n      .then(deck => !!deck\n        ? setExistingDeck(deck)\n        : loadDeck(options.selectedDeck))\n      .then(() => setInitialized(true));\n  }, []);\n\n  useEffect(() => {\n    if (!initialized) return;\n    loadDeck(options.selectedDeck);\n  },[options.selectedDeck]);\n\n  return [deck];\n}","\nexport const getDeck = (root: string, name: string) =>\n  fetch(`${root}/${name}.json`).then(res => res.json());\n","// TODO: refactor this to be platform-agnostic\nimport { Flashcard } from '../features/flashcard/flashcard';\nimport {Options} from '../features/options/Options'\nimport { useOptions } from \"../features/options/useOptions.hook\";\nimport { useDeck } from \"./useDeck.hook\";\n\nconst FlashCardPage = ({}) => {\n  const [options] = useOptions();\n  const [deck] = useDeck(); \n\n  if (!deck.length) {\n    return <article>...loading</article>;\n  }\n\n  return (\n    <article>\n      <h1 className=\"logo\">Flashcardly!</h1>\n      <section>\n        <Flashcard deck={deck}/>\n      </section>\n      <section style={{ paddingTop: \"2rem\" }}>\n        <Options />\n      </section>\n    </article>\n  );\n};\n\nexport default FlashCardPage;\n","import React, { useState } from 'react';\nimport './App.css';\nimport Storage from \"./services/storage/storage.web\";\nimport StorageProvider from \"./providers/storage.provider\";\nimport OptionsProvider from \"./features/options/options.provider\";\nimport FlashCardPage from \"./pages/flashcard.page\";\nimport { useOptions } from \"./features/options/useOptions.hook\";\n\nfunction App() {\n  return (\n    <StorageProvider.Provider value={Storage}>\n      <OptionsProvider>\n        <AppRoot />\n      </OptionsProvider>\n    </StorageProvider.Provider>\n  );\n}\n\nconst AppRoot = () => {\n  const [options, setOptions] = useOptions();\n  const { theme } = options;\n  const isLightTheme = theme === 'light';\n  const toggleToggle = () => {\n    const newTheme = isLightTheme ? \"dark\" : \"light\";\n    setOptions({ ...options, theme: newTheme });\n  }\n  // switch in left pos is off (light)\n  //                       on (dark)\n  return (\n    <div className={`App ${theme}`}>\n      <div className=\"switch-container\">\n        <label className=\"switch\">\n          <input onChange={toggleToggle} checked={isLightTheme} type=\"checkbox\" />\n          <span className=\"slider round\">\n            <span className=\"theme-icon--dark\">🌕</span>\n            <span className=\"theme-icon--light\">🌞</span>\n          </span>\n        </label>\n      </div>\n      <FlashCardPage />\n    </div>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}